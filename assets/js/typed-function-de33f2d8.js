function se(){return!0}function x(){return!1}function O(){}const ie="Argument is not a typed-function.";function fe(){function z(e){return typeof e=="object"&&e!==null&&e.constructor===Object}const ce=[{name:"number",test:function(e){return typeof e=="number"}},{name:"string",test:function(e){return typeof e=="string"}},{name:"boolean",test:function(e){return typeof e=="boolean"}},{name:"Function",test:function(e){return typeof e=="function"}},{name:"Array",test:Array.isArray},{name:"Date",test:function(e){return e instanceof Date}},{name:"RegExp",test:function(e){return e instanceof RegExp}},{name:"Object",test:z},{name:"null",test:function(e){return e===null}},{name:"undefined",test:function(e){return e===void 0}}],ae={name:"any",test:se,isAny:!0};let P,A,I=0,u={createCount:0};function T(e){const t=P.get(e);if(t)return t;let n='Unknown type "'+e+'"';const r=e.toLowerCase();let s;for(s of A)if(s.toLowerCase()===r){n+='. Did you mean "'+s+'" ?';break}throw new TypeError(n)}function F(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"any";const n=t?T(t).index:A.length,r=[];for(let o=0;o<e.length;++o){if(!e[o]||typeof e[o].name!="string"||typeof e[o].test!="function")throw new TypeError("Object with properties {name: string, test: function} expected");const c=e[o].name;if(P.has(c))throw new TypeError('Duplicate type name "'+c+'"');r.push(c),P.set(c,{name:c,test:e[o].test,isAny:e[o].isAny,index:n+o,conversionsTo:[]})}const s=A.slice(n);A=A.slice(0,n).concat(r).concat(s);for(let o=n+r.length;o<A.length;++o)P.get(A[o]).index=o}function B(){P=new Map,A=[],I=0,F([ae],!1)}B(),F(ce);function ue(){let e;for(e of A)P.get(e).conversionsTo=[];I=0}function G(e){const t=A.filter(n=>{const r=P.get(n);return!r.isAny&&r.test(e)});return t.length?t:["any"]}function j(e){return e&&typeof e=="function"&&"_typedFunctionData"in e}function H(e,t,n){if(!j(e))throw new TypeError(ie);const r=n&&n.exact,s=Array.isArray(t)?t.join(","):t,o=L(s),c=S(o);if(!r||c in e.signatures){const p=e._typedFunctionData.signatureMap.get(c);if(p)return p}const f=o.length;let a;if(r){a=[];let p;for(p in e.signatures)a.push(e._typedFunctionData.signatureMap.get(p))}else a=e._typedFunctionData.signatures;for(let p=0;p<f;++p){const h=o[p],m=[];let v;for(v of a){const d=U(v.params,p);if(!(!d||h.restParam&&!d.restParam)){if(!d.hasAny){const E=J(d);if(h.types.some(C=>!E.has(C.name)))continue}m.push(v)}}if(a=m,a.length===0)break}let i;for(i of a)if(i.params.length<=f)return i;throw new TypeError("Signature not found (signature: "+(e.name||"unnamed")+"("+S(o,", ")+"))")}function le(e,t,n){return H(e,t,n).implementation}function pe(e,t){const n=T(t);if(n.test(e))return e;const r=n.conversionsTo;if(r.length===0)throw new Error("There are no conversions to "+t+" defined.");for(let s=0;s<r.length;s++)if(T(r[s].from).test(e))return r[s].convert(e);throw new Error("Cannot convert "+e+" to "+t)}function S(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:",";return e.map(n=>n.name).join(t)}function he(e){const t=e.indexOf("...")===0,r=(t?e.length>3?e.slice(3):"any":e).split("|").map(f=>T(f.trim()));let s=!1,o=t?"...":"";return{types:r.map(function(f){return s=f.isAny||s,o+=f.name+"|",{name:f.name,typeIndex:f.index,test:f.test,isAny:f.isAny,conversion:null,conversionIndex:-1}}),name:o.slice(0,-1),hasAny:s,hasConversion:!1,restParam:t}}function me(e){const t=e.types.map(c=>c.name),n=Te(t);let r=e.hasAny,s=e.name;const o=n.map(function(c){const f=T(c.from);return r=f.isAny||r,s+="|"+c.from,{name:c.from,typeIndex:f.index,test:f.test,isAny:f.isAny,conversion:c,conversionIndex:c.index}});return{types:e.types.concat(o),name:s,hasAny:r,hasConversion:o.length>0,restParam:e.restParam}}function J(e){return e.typeSet||(e.typeSet=new Set,e.types.forEach(t=>e.typeSet.add(t.name))),e.typeSet}function L(e){const t=[];if(typeof e!="string")throw new TypeError("Signatures must be strings");const n=e.trim();if(n==="")return t;const r=n.split(",");for(let s=0;s<r.length;++s){const o=he(r[s].trim());if(o.restParam&&s!==r.length-1)throw new SyntaxError('Unexpected rest parameter "'+r[s]+'": only allowed for the last parameter');if(o.types.length===0)return null;t.push(o)}return t}function g(e){const t=b(e);return t?t.restParam:!1}function y(e){if(!e||e.types.length===0)return se;if(e.types.length===1)return T(e.types[0].name).test;if(e.types.length===2){const t=T(e.types[0].name).test,n=T(e.types[1].name).test;return function(s){return t(s)||n(s)}}else{const t=e.types.map(function(n){return T(n.name).test});return function(r){for(let s=0;s<t.length;s++)if(t[s](r))return!0;return!1}}}function ye(e){let t,n,r;if(g(e)){t=Z(e).map(y);const s=t.length,o=y(b(e)),c=function(f){for(let a=s;a<f.length;a++)if(!o(f[a]))return!1;return!0};return function(a){for(let i=0;i<t.length;i++)if(!t[i](a[i]))return!1;return c(a)&&a.length>=s+1}}else return e.length===0?function(o){return o.length===0}:e.length===1?(n=y(e[0]),function(o){return n(o[0])&&o.length===1}):e.length===2?(n=y(e[0]),r=y(e[1]),function(o){return n(o[0])&&r(o[1])&&o.length===2}):(t=e.map(y),function(o){for(let c=0;c<t.length;c++)if(!t[c](o[c]))return!1;return o.length===t.length})}function U(e,t){return t<e.length?e[t]:g(e)?b(e):null}function N(e,t){const n=U(e,t);return n?J(n):new Set}function Y(e){return e.conversion===null||e.conversion===void 0}function K(e,t){const n=new Set;return e.forEach(r=>{const s=N(r.params,t);let o;for(o of s)n.add(o)}),n.has("any")?["any"]:Array.from(n)}function Q(e,t,n){let r,s;const o=e||"unnamed";let c=n,f;for(f=0;f<t.length;f++){const h=[];if(c.forEach(m=>{const v=U(m.params,f),d=y(v);(f<m.params.length||g(m.params))&&d(t[f])&&h.push(m)}),h.length===0){if(s=K(c,f),s.length>0){const m=G(t[f]);return r=new TypeError("Unexpected type of argument in function "+o+" (expected: "+s.join(" or ")+", actual: "+m.join(" | ")+", index: "+f+")"),r.data={category:"wrongType",fn:o,index:f,actual:m,expected:s},r}}else c=h}const a=c.map(function(h){return g(h.params)?1/0:h.params.length});if(t.length<Math.min.apply(null,a))return s=K(c,f),r=new TypeError("Too few arguments in function "+o+" (expected: "+s.join(" or ")+", index: "+t.length+")"),r.data={category:"tooFewArgs",fn:o,index:t.length,expected:s},r;const i=Math.max.apply(null,a);if(t.length>i)return r=new TypeError("Too many arguments in function "+o+" (expected: "+i+", actual: "+t.length+")"),r.data={category:"tooManyArgs",fn:o,index:t.length,expectedLength:i},r;const p=[];for(let h=0;h<t.length;++h)p.push(G(t[h]).join("|"));return r=new TypeError('Arguments of type "'+p.join(", ")+'" do not match any of the defined signatures of function '+o+"."),r.data={category:"mismatch",actual:p},r}function V(e){let t=A.length+1;for(let n=0;n<e.types.length;n++)Y(e.types[n])&&(t=Math.min(t,e.types[n].typeIndex));return t}function W(e){let t=I+1;for(let n=0;n<e.types.length;n++)Y(e.types[n])||(t=Math.min(t,e.types[n].conversionIndex));return t}function ge(e,t){if(e.hasAny){if(!t.hasAny)return 1}else if(t.hasAny)return-1;if(e.restParam){if(!t.restParam)return 1}else if(t.restParam)return-1;if(e.hasConversion){if(!t.hasConversion)return 1}else if(t.hasConversion)return-1;const n=V(e)-V(t);if(n<0)return-1;if(n>0)return 1;const r=W(e)-W(t);return r<0?-1:r>0?1:0}function de(e,t){const n=e.params,r=t.params,s=b(n),o=b(r),c=g(n),f=g(r);if(c&&s.hasAny){if(!f||!o.hasAny)return 1}else if(f&&o.hasAny)return-1;let a=0,i=0,p;for(p of n)p.hasAny&&++a,p.hasConversion&&++i;let h=0,m=0;for(p of r)p.hasAny&&++h,p.hasConversion&&++m;if(a!==h)return a-h;if(c&&s.hasConversion){if(!f||!o.hasConversion)return 1}else if(f&&o.hasConversion)return-1;if(i!==m)return i-m;if(c){if(!f)return 1}else if(f)return-1;const v=(n.length-r.length)*(c?-1:1);if(v!==0)return v;const d=[];let E=0;for(let k=0;k<n.length;++k){const M=ge(n[k],r[k]);d.push(M),E+=M}if(E!==0)return E;let C;for(C of d)if(C!==0)return C;return 0}function Te(e){if(e.length===0)return[];const t=e.map(T);e.length>1&&t.sort((s,o)=>s.index-o.index);let n=t[0].conversionsTo;if(e.length===1)return n;n=n.concat([]);const r=new Set(e);for(let s=1;s<t.length;++s){let o;for(o of t[s].conversionsTo)r.has(o.from)||(n.push(o),r.add(o.from))}return n}function ve(e,t){let n=t;if(e.some(s=>s.hasConversion)){const s=g(e),o=e.map(we);n=function(){const f=[],a=s?arguments.length-1:arguments.length;for(let i=0;i<a;i++)f[i]=o[i](arguments[i]);return s&&(f[a]=arguments[a].map(o[a])),t.apply(this,f)}}let r=n;if(g(e)){const s=e.length-1;r=function(){return n.apply(this,q(arguments,0,s).concat([q(arguments,s)]))}}return r}function we(e){let t,n,r,s;const o=[],c=[];switch(e.types.forEach(function(f){f.conversion&&(o.push(T(f.conversion.from).test),c.push(f.conversion.convert))}),c.length){case 0:return function(a){return a};case 1:return t=o[0],r=c[0],function(a){return t(a)?r(a):a};case 2:return t=o[0],n=o[1],r=c[0],s=c[1],function(a){return t(a)?r(a):n(a)?s(a):a};default:return function(a){for(let i=0;i<c.length;i++)if(o[i](a))return c[i](a);return a}}}function xe(e){function t(n,r,s){if(r<n.length){const o=n[r];let c=[];if(o.restParam){const f=o.types.filter(Y);f.length<o.types.length&&c.push({types:f,name:"..."+f.map(a=>a.name).join("|"),hasAny:f.some(a=>a.isAny),hasConversion:!1,restParam:!0}),c.push(o)}else c=o.types.map(function(f){return{types:[f],name:f.name,hasAny:f.isAny,hasConversion:f.conversion,restParam:!1}});return Oe(c,function(f){return t(n,r+1,s.concat([f]))})}else return[s]}return t(e,0,[])}function Ae(e,t){const n=Math.max(e.length,t.length);for(let f=0;f<n;f++){const a=N(e,f),i=N(t,f);let p=!1,h;for(h of i)if(a.has(h)){p=!0;break}if(!p)return!1}const r=e.length,s=t.length,o=g(e),c=g(t);return o?c?r===s:s>=r:c?r>=s:r===s}function Ee(e){return e.map(t=>ne(t)?ee(t.referToSelf.callback):te(t)?$(t.referTo.references,t.referTo.callback):t)}function Ce(e,t,n){const r=[];let s;for(s of e){let o=n[s];if(typeof o!="number")throw new TypeError('No definition for referenced signature "'+s+'"');if(o=t[o],typeof o!="function")return!1;r.push(o)}return r}function Pe(e,t,n){const r=Ee(e),s=new Array(r.length).fill(!1);let o=!0;for(;o;){o=!1;let c=!0;for(let f=0;f<r.length;++f){if(s[f])continue;const a=r[f];if(ne(a))r[f]=a.referToSelf.callback(n),r[f].referToSelf=a.referToSelf,s[f]=!0,c=!1;else if(te(a)){const i=Ce(a.referTo.references,r,t);i?(r[f]=a.referTo.callback.apply(this,i),r[f].referTo=a.referTo,s[f]=!0,c=!1):o=!0}}if(c&&o)throw new SyntaxError("Circular reference detected in resolving typed.referTo")}return r}function Se(e){const t=/\bthis(\(|\.signatures\b)/;Object.keys(e).forEach(n=>{const r=e[n];if(t.test(r.toString()))throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.")})}function be(e,t){if(u.createCount++,Object.keys(t).length===0)throw new SyntaxError("No signatures provided");u.warnAgainstDeprecatedThis&&Se(t);const n=[],r=[],s={},o=[];let c;for(c in t){if(!Object.prototype.hasOwnProperty.call(t,c))continue;const l=L(c);if(!l)continue;n.forEach(function(R){if(Ae(R,l))throw new TypeError('Conflicting signatures "'+S(R)+'" and "'+S(l)+'".')}),n.push(l);const w=r.length;r.push(t[c]);const ct=l.map(me);let _;for(_ of xe(ct)){const R=S(_);o.push({params:_,name:R,fn:w}),_.every(at=>!at.hasConversion)&&(s[R]=w)}}o.sort(de);const f=Pe(r,s,D);let a;for(a in s)Object.prototype.hasOwnProperty.call(s,a)&&(s[a]=f[s[a]]);const i=[],p=new Map;for(a of o)p.has(a.name)||(a.fn=f[a.fn],i.push(a),p.set(a.name,a));const h=i[0]&&i[0].params.length<=2&&!g(i[0].params),m=i[1]&&i[1].params.length<=2&&!g(i[1].params),v=i[2]&&i[2].params.length<=2&&!g(i[2].params),d=i[3]&&i[3].params.length<=2&&!g(i[3].params),E=i[4]&&i[4].params.length<=2&&!g(i[4].params),C=i[5]&&i[5].params.length<=2&&!g(i[5].params),k=h&&m&&v&&d&&E&&C;for(let l=0;l<i.length;++l)i[l].test=ye(i[l].params);const M=h?y(i[0].params[0]):x,Me=m?y(i[1].params[0]):x,_e=v?y(i[2].params[0]):x,Fe=d?y(i[3].params[0]):x,Le=E?y(i[4].params[0]):x,Ue=C?y(i[5].params[0]):x,Ne=h?y(i[0].params[1]):x,Ye=m?y(i[1].params[1]):x,qe=v?y(i[2].params[1]):x,ze=d?y(i[3].params[1]):x,Be=E?y(i[4].params[1]):x,Ge=C?y(i[5].params[1]):x;for(let l=0;l<i.length;++l)i[l].implementation=ve(i[l].params,i[l].fn);const He=h?i[0].implementation:O,Je=m?i[1].implementation:O,Ke=v?i[2].implementation:O,Qe=d?i[3].implementation:O,Ve=E?i[4].implementation:O,We=C?i[5].implementation:O,Xe=h?i[0].params.length:-1,Ze=m?i[1].params.length:-1,$e=v?i[2].params.length:-1,et=d?i[3].params.length:-1,tt=E?i[4].params.length:-1,nt=C?i[5].params.length:-1,rt=k?6:0,ot=i.length,st=i.map(l=>l.test),it=i.map(l=>l.implementation),ft=function(){for(let w=rt;w<ot;w++)if(st[w](arguments))return it[w].apply(this,arguments);return u.onMismatch(e,arguments,i)};function D(l,w){return arguments.length===Xe&&M(l)&&Ne(w)?He.apply(this,arguments):arguments.length===Ze&&Me(l)&&Ye(w)?Je.apply(this,arguments):arguments.length===$e&&_e(l)&&qe(w)?Ke.apply(this,arguments):arguments.length===et&&Fe(l)&&ze(w)?Qe.apply(this,arguments):arguments.length===tt&&Le(l)&&Be(w)?Ve.apply(this,arguments):arguments.length===nt&&Ue(l)&&Ge(w)?We.apply(this,arguments):ft.apply(this,arguments)}try{Object.defineProperty(D,"name",{value:e})}catch{}return D.signatures=s,D._typedFunctionData={signatures:i,signatureMap:p},D}function X(e,t,n){throw Q(e,t,n)}function Z(e){return q(e,0,e.length-1)}function b(e){return e[e.length-1]}function q(e,t,n){return Array.prototype.slice.call(e,t,n)}function ke(e,t){for(let n=0;n<e.length;n++)if(t(e[n]))return e[n]}function Oe(e,t){return Array.prototype.concat.apply([],e.map(t))}function je(){const e=Z(arguments).map(n=>S(L(n))),t=b(arguments);if(typeof t!="function")throw new TypeError("Callback function expected as last argument");return $(e,t)}function $(e,t){return{referTo:{references:e,callback:t}}}function ee(e){if(typeof e!="function")throw new TypeError("Callback function expected as first argument");return{referToSelf:{callback:e}}}function te(e){return e&&typeof e.referTo=="object"&&Array.isArray(e.referTo.references)&&typeof e.referTo.callback=="function"}function ne(e){return e&&typeof e.referToSelf=="object"&&typeof e.referToSelf.callback=="function"}function re(e,t){if(!e)return t;if(t&&t!==e){const n=new Error("Function names do not match (expected: "+e+", actual: "+t+")");throw n.data={actual:t,expected:e},n}return e}function De(e){let t;for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&(j(e[n])||typeof e[n].signature=="string")&&(t=re(t,e[n].name));return t}function Re(e,t){let n;for(n in t)if(Object.prototype.hasOwnProperty.call(t,n)){if(n in e&&t[n]!==e[n]){const r=new Error('Signature "'+n+'" is defined twice');throw r.data={signature:n,sourceFunction:t[n],destFunction:e[n]},r}e[n]=t[n]}}const Ie=u;u=function(e){const t=typeof e=="string",n=t?1:0;let r=t?e:"";const s={};for(let o=n;o<arguments.length;++o){const c=arguments[o];let f={},a;if(typeof c=="function"?(a=c.name,typeof c.signature=="string"?f[c.signature]=c:j(c)&&(f=c.signatures)):z(c)&&(f=c,t||(a=De(c))),Object.keys(f).length===0){const i=new TypeError("Argument to 'typed' at index "+o+" is not a (typed) function, nor an object with signatures as keys and functions as values.");throw i.data={index:o,argument:c},i}t||(r=re(r,a)),Re(s,f)}return be(r||"",s)},u.create=fe,u.createCount=Ie.createCount,u.onMismatch=X,u.throwMismatchError=X,u.createError=Q,u.clear=B,u.clearConversions=ue,u.addTypes=F,u._findType=T,u.referTo=je,u.referToSelf=ee,u.convert=pe,u.findSignature=H,u.find=le,u.isTypedFunction=j,u.warnAgainstDeprecatedThis=!0,u.addType=function(e,t){let n="any";t!==!1&&P.has("Object")&&(n="Object"),u.addTypes([e],n)};function oe(e){if(!e||typeof e.from!="string"||typeof e.to!="string"||typeof e.convert!="function")throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");if(e.to===e.from)throw new SyntaxError('Illegal to define conversion from "'+e.from+'" to itself.')}return u.addConversion=function(e){oe(e);const t=T(e.to);if(t.conversionsTo.every(function(n){return n.from!==e.from}))t.conversionsTo.push({from:e.from,convert:e.convert,index:I++});else throw new Error('There is already a conversion from "'+e.from+'" to "'+t.name+'"')},u.addConversions=function(e){e.forEach(u.addConversion)},u.removeConversion=function(e){oe(e);const t=T(e.to),n=ke(t.conversionsTo,s=>s.from===e.from);if(!n)throw new Error("Attempt to remove nonexistent conversion from "+e.from+" to "+e.to);if(n.convert!==e.convert)throw new Error("Conversion to remove does not match existing conversion");const r=t.conversionsTo.indexOf(n);t.conversionsTo.splice(r,1)},u.resolve=function(e,t){if(!j(e))throw new TypeError(ie);const n=e._typedFunctionData.signatures;for(let r=0;r<n.length;++r)if(n[r].test(t))return n[r];return null},u}const ut=fe();export{ut as t};
