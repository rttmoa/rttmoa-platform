import{a as vt,r as R}from"./react-12b51ca5.js";import{s as Qt}from"./use-sync-external-store-ad55a9d4.js";const U=()=>{},O=U(),rt=Object,a=t=>t===O,I=t=>typeof t=="function",M=(t,e)=>({...t,...e}),Zt=t=>I(t.then),st=new WeakMap;let te=0;const Q=t=>{const e=typeof t,n=t&&t.constructor,i=n==Date;let s,r;if(rt(t)===t&&!i&&n!=RegExp){if(s=st.get(t),s)return s;if(s=++te+"~",st.set(t,s),n==Array){for(s="@",r=0;r<t.length;r++)s+=Q(t[r])+",";st.set(t,s)}if(n==rt){s="#";const c=rt.keys(t).sort();for(;!a(r=c.pop());)a(t[r])||(s+=r+":"+Q(t[r])+",");st.set(t,s)}}else s=i?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return s},W=new WeakMap,ft={},ot={},Ct="undefined",at=typeof window!=Ct,Rt=typeof document!=Ct,ee=()=>at&&typeof window.requestAnimationFrame!=Ct,Pt=(t,e)=>{const n=W.get(t);return[()=>!a(e)&&t.get(e)||ft,i=>{if(!a(e)){const s=t.get(e);e in ot||(ot[e]=s),n[5](e,M(s,i),s||ft)}},n[6],()=>!a(e)&&e in ot?ot[e]:!a(e)&&t.get(e)||ft]};let ht=!0;const ne=()=>ht,[Tt,_t]=at&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[U,U],se=()=>{const t=Rt&&document.visibilityState;return a(t)||t!=="hidden"},oe=t=>(Rt&&document.addEventListener("visibilitychange",t),Tt("focus",t),()=>{Rt&&document.removeEventListener("visibilitychange",t),_t("focus",t)}),re=t=>{const e=()=>{ht=!0,t()},n=()=>{ht=!1};return Tt("online",e),Tt("offline",n),()=>{_t("online",e),_t("offline",n)}},ie={isOnline:ne,isVisible:se},ae={initFocus:oe,initReconnect:re},Ft=!vt.useId,Z=!at||"Deno"in window,ce=t=>ee()?window.requestAnimationFrame(t):setTimeout(t,1),it=Z?R.useEffect:R.useLayoutEffect,dt=typeof navigator<"u"&&navigator.connection,xt=!Z&&dt&&(["slow-2g","2g"].includes(dt.effectiveType)||dt.saveData),pt=t=>{if(I(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?Q(t):"",[t,e]};let ue=0;const gt=()=>++ue,Ut=0,qt=1,Ht=2,le=3;var X={__proto__:null,ERROR_REVALIDATE_EVENT:le,FOCUS_EVENT:Ut,MUTATE_EVENT:Ht,RECONNECT_EVENT:qt};async function $t(...t){const[e,n,i,s]=t,r=M({populateCache:!0,throwOnError:!0},typeof s=="boolean"?{revalidate:s}:s||{});let c=r.populateCache;const d=r.rollbackOnError;let u=r.optimisticData;const A=w=>typeof d=="function"?d(w):d!==!1,v=r.throwOnError;if(I(n)){const w=n,T=[],L=e.keys();for(const g of L)!/^\$(inf|sub)\$/.test(g)&&w(e.get(g)._k)&&T.push(g);return Promise.all(T.map(_))}return _(n);async function _(w){const[T]=pt(w);if(!T)return;const[L,g]=Pt(e,T),[ct,o,tt,G]=W.get(e),P=()=>{const V=ct[T];return(I(r.revalidate)?r.revalidate(L().data,w):r.revalidate!==!1)&&(delete tt[T],delete G[T],V&&V[0])?V[0](Ht).then(()=>L().data):L().data};if(t.length<3)return P();let C=i,D;const H=gt();o[T]=[H,0];const h=!a(u),$=L(),N=$.data,j=$._c,q=a(j)?N:j;if(h&&(u=I(u)?u(q,N):u,g({data:u,_c:q})),I(C))try{C=C(q)}catch(V){D=V}if(C&&Zt(C))if(C=await C.catch(V=>{D=V}),H!==o[T][0]){if(D)throw D;return C}else D&&h&&A(D)&&(c=!0,g({data:q,_c:O}));if(c&&!D)if(I(c)){const V=c(C,q);g({data:V,error:O,_c:O})}else g({data:C,error:O,_c:O});if(o[T][1]=gt(),Promise.resolve(P()).then(()=>{g({_c:O})}),D){if(v)throw D;return}return C}}const Wt=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},jt=(t,e)=>{if(!W.has(t)){const n=M(ae,e),i={},s=$t.bind(O,t);let r=U;const c={},d=(v,_)=>{const w=c[v]||[];return c[v]=w,w.push(_),()=>w.splice(w.indexOf(_),1)},u=(v,_,w)=>{t.set(v,_);const T=c[v];if(T)for(const L of T)L(_,w)},A=()=>{if(!W.has(t)&&(W.set(t,[i,{},{},{},s,u,d]),!Z)){const v=n.initFocus(setTimeout.bind(O,Wt.bind(O,i,Ut))),_=n.initReconnect(setTimeout.bind(O,Wt.bind(O,i,qt)));r=()=>{v&&v(),_&&_(),W.delete(t)}}};return A(),[t,s,A,r]}return[t,W.get(t)[4]]},fe=(t,e,n,i,s)=>{const r=n.errorRetryCount,c=s.retryCount,d=~~((Math.random()+.5)*(1<<(c<8?c:8)))*n.errorRetryInterval;!a(r)&&c>r||setTimeout(i,d,s)},de=(t,e)=>Q(t)==Q(e),[wt,Ee]=jt(new Map),kt=M({onLoadingSlow:U,onSuccess:U,onError:U,onErrorRetry:fe,onDiscarded:U,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:xt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:xt?5e3:3e3,compare:de,isPaused:()=>!1,cache:wt,mutate:Ee,fallback:{}},ie),zt=(t,e)=>{const n=M(t,e);if(e){const{use:i,fallback:s}=t,{use:r,fallback:c}=e;i&&r&&(n.use=i.concat(r)),s&&c&&(n.fallback=M(s,c))}return n},mt=R.createContext({}),Re=t=>{const{value:e}=t,n=R.useContext(mt),i=I(e),s=R.useMemo(()=>i?e(n):e,[i,n,e]),r=R.useMemo(()=>i?s:zt(n,s),[i,n,s]),c=s&&s.provider,d=R.useRef(O);c&&!d.current&&(d.current=jt(c(r.cache||wt),s));const u=d.current;return u&&(r.cache=u[0],r.mutate=u[1]),it(()=>{if(u)return u[2]&&u[2](),u[3]},[]),R.createElement(mt.Provider,M(t,{value:r}))},he="$inf$",Bt=at&&window.__SWR_DEVTOOLS_USE__,Te=Bt?window.__SWR_DEVTOOLS_USE__:[],_e=()=>{Bt&&(window.__SWR_DEVTOOLS_REACT__=vt)},ge=t=>I(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],me=()=>M(kt,R.useContext(mt)),ve=t=>(e,n,i)=>t(e,n&&((...r)=>{const[c]=pt(e),[,,,d]=W.get(wt);if(c.startsWith(he))return n(...r);const u=d[c];return a(u)?n(...r):(delete d[c],u)}),i),Ce=Te.concat(ve),pe=t=>function(...n){const i=me(),[s,r,c]=ge(n),d=zt(i,c);let u=t;const{use:A}=d,v=(A||[]).concat(Ce);for(let _=v.length;_--;)u=v[_](u);return u(s,r||d.fetcher||null,d)},we=(t,e,n)=>{const i=e[t]||(e[t]=[]);return i.push(n),()=>{const s=i.indexOf(n);s>=0&&(i[s]=i[i.length-1],i.pop())}};_e();const Mt=vt.use||(t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t)}),Et={dedupe:!0},Se=(t,e,n)=>{const{cache:i,compare:s,suspense:r,fallbackData:c,revalidateOnMount:d,revalidateIfStale:u,refreshInterval:A,refreshWhenHidden:v,refreshWhenOffline:_,keepPreviousData:w}=n,[T,L,g,ct]=W.get(i),[o,tt]=pt(t),G=R.useRef(!1),P=R.useRef(!1),C=R.useRef(o),D=R.useRef(e),H=R.useRef(n),h=()=>H.current,$=()=>h().isVisible()&&h().isOnline(),[N,j,q,V]=Pt(i,o),k=R.useRef({}).current,Jt=a(c)?n.fallback[o]:c,St=(l,f)=>{for(const p in k){const E=p;if(E==="data"){if(!s(l[E],f[E])&&(!a(l[E])||!s(nt,f[E])))return!1}else if(f[E]!==l[E])return!1}return!0},Ot=R.useMemo(()=>{const l=(()=>!o||!e?!1:a(d)?h().isPaused()||r?!1:a(u)?!0:u:d)(),f=S=>{const F=M(S);return delete F._k,l?{isValidating:!0,isLoading:!0,...F}:F},p=N(),E=V(),y=f(p),K=p===E?y:f(E);let m=y;return[()=>{const S=f(N());return St(S,m)?(m.data=S.data,m.isLoading=S.isLoading,m.isValidating=S.isValidating,m.error=S.error,m):(m=S,S)},()=>K]},[i,o]),z=Qt.useSyncExternalStore(R.useCallback(l=>q(o,(f,p)=>{St(p,f)||l()}),[i,o]),Ot[0],Ot[1]),Dt=!G.current,Kt=T[o]&&T[o].length>0,B=z.data,J=a(B)?Jt:B,et=z.error,bt=R.useRef(J),nt=w?a(B)?bt.current:B:J,At=(()=>Kt&&!a(et)?!1:Dt&&!a(d)?d:h().isPaused()?!1:r?a(J)?!1:u:a(J)||u)(),Vt=!!(o&&e&&Dt&&At),Gt=a(z.isValidating)?Vt:z.isValidating,Yt=a(z.isLoading)?Vt:z.isLoading,Y=R.useCallback(async l=>{const f=D.current;if(!o||!f||P.current||h().isPaused())return!1;let p,E,y=!0;const K=l||{},m=!g[o]||!K.dedupe,S=()=>Ft?!P.current&&o===C.current&&G.current:o===C.current,F={isValidating:!1,isLoading:!1},Lt=()=>{j(F)},Nt=()=>{const b=g[o];b&&b[1]===E&&delete g[o]},yt={isValidating:!0};a(N().data)&&(yt.isLoading=!0);try{if(m&&(j(yt),n.loadingTimeout&&a(N().data)&&setTimeout(()=>{y&&S()&&h().onLoadingSlow(o,n)},n.loadingTimeout),g[o]=[f(tt),gt()]),[p,E]=g[o],p=await p,m&&setTimeout(Nt,n.dedupingInterval),!g[o]||g[o][1]!==E)return m&&S()&&h().onDiscarded(o),!1;F.error=O;const b=L[o];if(!a(b)&&(E<=b[0]||E<=b[1]||b[1]===0))return Lt(),m&&S()&&h().onDiscarded(o),!1;const x=N().data;F.data=s(x,p)?x:p,m&&S()&&h().onSuccess(p,o,n)}catch(b){Nt();const x=h(),{shouldRetryOnError:ut}=x;x.isPaused()||(F.error=b,m&&S()&&(x.onError(b,o,x),(ut===!0||I(ut)&&ut(b))&&(!h().revalidateOnFocus||!h().revalidateOnReconnect||$())&&x.onErrorRetry(b,o,x,Xt=>{const lt=T[o];lt&&lt[0]&&lt[0](X.ERROR_REVALIDATE_EVENT,Xt)},{retryCount:(K.retryCount||0)+1,dedupe:!0})))}return y=!1,Lt(),!0},[o,i]),It=R.useCallback((...l)=>$t(i,C.current,...l),[]);if(it(()=>{D.current=e,H.current=n,a(B)||(bt.current=B)}),it(()=>{if(!o)return;const l=Y.bind(O,Et);let f=0;const E=we(o,T,(y,K={})=>{if(y==X.FOCUS_EVENT){const m=Date.now();h().revalidateOnFocus&&m>f&&$()&&(f=m+h().focusThrottleInterval,l())}else if(y==X.RECONNECT_EVENT)h().revalidateOnReconnect&&$()&&l();else{if(y==X.MUTATE_EVENT)return Y();if(y==X.ERROR_REVALIDATE_EVENT)return Y(K)}});return P.current=!1,C.current=o,G.current=!0,j({_k:tt}),At&&(a(J)||Z?l():ce(l)),()=>{P.current=!0,E()}},[o]),it(()=>{let l;function f(){const E=I(A)?A(N().data):A;E&&l!==-1&&(l=setTimeout(p,E))}function p(){!N().error&&(v||h().isVisible())&&(_||h().isOnline())?Y(Et).then(f):f()}return f(),()=>{l&&(clearTimeout(l),l=-1)}},[A,v,_,o]),R.useDebugValue(nt),r&&a(J)&&o){if(!Ft&&Z)throw new Error("Fallback data is required when using suspense in SSR.");D.current=e,H.current=n,P.current=!1;const l=ct[o];if(!a(l)){const f=It(l);Mt(f)}if(a(et)){const f=Y(Et);a(nt)||(f.status="fulfilled",f.value=!0),Mt(f)}else throw et}return{mutate:It,get data(){return k.data=!0,nt},get error(){return k.error=!0,et},get isValidating(){return k.isValidating=!0,Gt},get isLoading(){return k.isLoading=!0,Yt}}},be=rt.defineProperty(Re,"defaultValue",{value:kt}),Ae=pe(Se);export{be as S,Ae as a,me as u};
